signature substitutionTheory =
sig
  type thm = Thm.thm

  (*  Definitions  *)
    val extend_env_def : thm
    val fmla_size_def : thm
    val frees_def : thm
    val gv_def : thm
    val l_Sub_def : thm
    val rf_def : thm
    val setsat_def : thm
    val variant_spec : thm
    val vars_def : thm

  (*  Theorems  *)
    val COND_NOT : thm
    val COND_NOT_DISJ : thm
    val EQ_SUBSET_SUBSET : thm
    val INSERT_INSERT_DELETE : thm
    val Subst : thm
    val Subst_LEM : thm
    val Subst_def : thm
    val Subst_ind : thm
    val Subst_l_Sub : thm
    val Subst_not_free : thm
    val Subst_same_size : thm
    val UNION_SUBSET_MONOTONIC : thm
    val alpha_LEM : thm
    val alpha_frees : thm
    val alpha_remove : thm
    val extend_env_mmUpdate_EQ : thm
    val extend_env_mmUpdate_lemma : thm
    val fmla_size_ind : thm
    val fmla_size_induction : thm
    val frees_LEM : thm
    val frees_SUBSET_vars : thm
    val frees_are_vars : thm
    val frees_finite : thm
    val fv_1_1 : thm
    val fv_BIJ : thm
    val fv_IN_gf : thm
    val fv_LEM : thm
    val fv_append : thm
    val fv_def : thm
    val fv_ind : thm
    val fv_inj : thm
    val fv_not_in : thm
    val gf_append : thm
    val gf_def : thm
    val gf_delete : thm
    val gf_empty : thm
    val gf_finite : thm
    val gf_im : thm
    val gf_ind : thm
    val gf_insert : thm
    val gf_monotone : thm
    val gf_union : thm
    val gfp_monotone : thm
    val gl_append : thm
    val gl_def : thm
    val gl_ind : thm
    val half_gl_ok : thm
    val in_not_in_not_eq : thm
    val l_Sub_ID : thm
    val l_Sub_ID_CONS : thm
    val l_Sub_append : thm
    val l_Sub_nil : thm
    val l_Sub_same_size : thm
    val last_extension_counts : thm
    val last_update_counts : thm
    val lfp_monotone : thm
    val mmsat_setsat : thm
    val muvar_not_free : thm
    val not_in_gf : thm
    val nuvar_not_free : thm
    val ok_r_def : thm
    val ok_r_gl_insert : thm
    val ok_r_ind : thm
    val ok_r_subset : thm
    val ok_to_unroll_mu : thm
    val ok_to_unroll_nu : thm
    val pair_list_induction : thm
    val setsat_EQ_satFun : thm
    val setsat_is_mmfn_UNIV : thm
    val setsat_lemma : thm
    val setsat_monotone : thm
    val silly_extend : thm
    val simple_ok_r_gl : thm
    val simple_ok_r_gl_mu : thm
    val simple_ok_r_gl_nu : thm
    val uneq_extensions_commute : thm
    val uneq_mmUpdates_commute : thm
    val unfold_mu_LEM : thm
    val unfold_nu_LEM : thm
    val variant_EXISTS : thm
    val variant_not_in : thm
    val vars_finite : thm

  val substitution_grammars : type_grammar.grammar * term_grammar.grammar
(*
   [mmFoundation] Parent theory of "substitution"

   [res_quan] Parent theory of "substitution"

   [extend_env_def]  Definition

      |- ‚àÄx v f. extend_env x v f = (Œªy. if y = x then v else f y)

   [fmla_size_def]  Definition

      |- (fmla_size tt = 0) ‚àß (fmla_size ff = 0) ‚àß
         (‚àÄZ. fmla_size (propmm Z) = 1) ‚àß
         (‚àÄf1 f2.
            fmla_size (f1 andmm f2) = 1 + fmla_size f1 + fmla_size f2) ‚àß
         (‚àÄf1 f2.
            fmla_size (f1 ormm f2) = 1 + fmla_size f1 + fmla_size f2) ‚àß
         (‚àÄActions f. fmla_size (Box Actions f) = 1 + fmla_size f) ‚àß
         (‚àÄActions f. fmla_size (Dia Actions f) = 1 + fmla_size f) ‚àß
         (‚àÄZ f. fmla_size (nu Z f) = 1 + fmla_size f) ‚àß
         ‚àÄZ f. fmla_size (mu Z f) = 1 + fmla_size f

   [frees_def]  Definition

      |- (frees tt = ‚àÖ) ‚àß (frees ff = ‚àÖ) ‚àß (‚àÄZ. frees (propmm Z) = {Z}) ‚àß
         (‚àÄf1 f2. frees (f1 andmm f2) = frees f1 ‚à™ frees f2) ‚àß
         (‚àÄf1 f2. frees (f1 ormm f2) = frees f1 ‚à™ frees f2) ‚àß
         (‚àÄActions f. frees (Box Actions f) = frees f) ‚àß
         (‚àÄActions f. frees (Dia Actions f) = frees f) ‚àß
         (‚àÄZ f. frees (nu Z f) = frees f DELETE Z) ‚àß
         ‚àÄZ f. frees (mu Z f) = frees f DELETE Z

   [gv_def]  Definition

      |- ‚àÄl Z fs. gv l Z fs = fv (gl l Z fs) Z

   [l_Sub_def]  Definition

      |- (‚àÄl. l_Sub l tt = tt) ‚àß (‚àÄl. l_Sub l ff = ff) ‚àß
         (‚àÄl Y. l_Sub l (propmm Y) = propmm (fv l Y)) ‚àß
         (‚àÄl P Q. l_Sub l (P andmm Q) = l_Sub l P andmm l_Sub l Q) ‚àß
         (‚àÄl P Q. l_Sub l (P ormm Q) = l_Sub l P ormm l_Sub l Q) ‚àß
         (‚àÄl Actions P.
            l_Sub l (Box Actions P) = Box Actions (l_Sub l P)) ‚àß
         (‚àÄl Actions P.
            l_Sub l (Dia Actions P) = Dia Actions (l_Sub l P)) ‚àß
         (‚àÄl Z P.
            l_Sub l (nu Z P) =
            (let
               fs = frees P ;
               (Z',l') = (gv l Z fs,gl l Z fs)
             in
               nu Z' (l_Sub l' P))) ‚àß
         ‚àÄl Z P.
           l_Sub l (mu Z P) =
           (let
              fs = frees P ;
              (Z',l') = (gv l Z fs,gl l Z fs)
            in
              mu Z' (l_Sub l' P))

   [rf_def]  Definition

      |- ‚àÄY X fs. rf Y X fs = if X ‚àà fs then Y INSERT fs DELETE X else fs

   [setsat_def]  Definition

      |- ‚àÄTrans f V. setsat Trans f V = {E | (E,Trans,V) mmsat f}

   [variant_spec]  Definition

      |- ‚àÄexclvars.
           INFINITE ùïå(:'variable) ‚áí
           FINITE exclvars ‚áí
           ‚àÄv. variant exclvars v ‚àâ exclvars

   [vars_def]  Definition

      |- (vars tt = ‚àÖ) ‚àß (vars ff = ‚àÖ) ‚àß (‚àÄZ. vars (propmm Z) = {Z}) ‚àß
         (‚àÄf1 f2. vars (f1 andmm f2) = vars f1 ‚à™ vars f2) ‚àß
         (‚àÄf1 f2. vars (f1 ormm f2) = vars f1 ‚à™ vars f2) ‚àß
         (‚àÄActions f. vars (Box Actions f) = vars f) ‚àß
         (‚àÄActions f. vars (Dia Actions f) = vars f) ‚àß
         (‚àÄZ f. vars (nu Z f) = vars f ‚à™ {Z}) ‚àß
         ‚àÄZ f. vars (mu Z f) = vars f ‚à™ {Z}

   [COND_NOT]  Theorem

      |- ‚àÄP A B. (if ¬¨P then A else B) = if P then B else A

   [COND_NOT_DISJ]  Theorem

      |- ‚àÄP Q A B.
           (if ¬¨Q ‚à® P then A else B) = if P then A else if Q then B else A

   [EQ_SUBSET_SUBSET]  Theorem

      |- ‚àÄs1 s2. (s1 = s2) ‚áî s1 ‚äÜ s2 ‚àß s2 ‚äÜ s1

   [INSERT_INSERT_DELETE]  Theorem

      |- ‚àÄa t. a INSERT t DELETE a = a INSERT t

   [Subst]  Theorem

      |- INFINITE ùïå(:Œ≤) ‚áí
         (Subst p X tt = tt) ‚àß (Subst p X ff = ff) ‚àß
         (Subst p X (propmm Z) = if Z = X then p else propmm Z) ‚àß
         (Subst p X (Fm1 andmm Fm2) = Subst p X Fm1 andmm Subst p X Fm2) ‚àß
         (Subst p X (Fm1 ormm Fm2) = Subst p X Fm1 ormm Subst p X Fm2) ‚àß
         (Subst p X (Box Actions Fm) = Box Actions (Subst p X Fm)) ‚àß
         (Subst p X (Dia Actions Fm) = Dia Actions (Subst p X Fm)) ‚àß
         (Subst p X (nu Z Fm) =
          (let
             fs = frees Fm
           in
             if X ‚àâ frees (nu Z Fm) then nu Z Fm
             else if Z ‚àà frees p then
               (let
                  Z' = variant (frees p ‚à™ fs) Z
                in
                  nu Z' (Subst p X (Subst (propmm Z') Z Fm)))
             else nu Z (Subst p X Fm))) ‚àß
         (Subst p X (mu Z Fm) =
          (let
             fs = frees Fm
           in
             if X ‚àâ frees (mu Z Fm) then mu Z Fm
             else if Z ‚àà frees p then
               (let
                  Z' = variant (frees p ‚à™ fs) Z
                in
                  mu Z' (Subst p X (Subst (propmm Z') Z Fm)))
             else mu Z (Subst p X Fm)))

   [Subst_LEM]  Theorem

      |- ‚àÄTrans Fm p Z V.
           INFINITE ùïå(:Œ≤) ‚áí
           (setsat Trans (Subst p Z Fm) V =
            setsat Trans Fm (extend_env Z (setsat Trans p V) V))

   [Subst_def]  Theorem

      |- (Subst N X tt = tt) ‚àß (Subst N X ff = ff) ‚àß
         (Subst N X (propmm Y) = if Y = X then N else propmm Y) ‚àß
         (Subst N X (P andmm Q) = Subst N X P andmm Subst N X Q) ‚àß
         (Subst N X (P ormm Q) = Subst N X P ormm Subst N X Q) ‚àß
         (Subst N X (Box Actions P) = Box Actions (Subst N X P)) ‚àß
         (Subst N X (Dia Actions P) = Dia Actions (Subst N X P)) ‚àß
         (Subst N X (nu Z P) =
          (let
             fs = frees P
           in
             if X ‚àâ fs ‚à® (X = Z) then nu Z P
             else if Z ‚àà frees N then
               (let
                  W = variant (frees N ‚à™ fs) Z
                in
                  nu W (Subst N X (l_Sub [(Z,W)] P)))
             else nu Z (Subst N X P))) ‚àß
         (Subst N X (mu Z P) =
          (let
             fs = frees P
           in
             if X ‚àâ fs ‚à® (X = Z) then mu Z P
             else if Z ‚àà frees N then
               (let
                  W = variant (frees N ‚à™ fs) Z
                in
                  mu W (Subst N X (l_Sub [(Z,W)] P)))
             else mu Z (Subst N X P)))

   [Subst_ind]  Theorem

      |- ‚àÄP'.
           (‚àÄN X. P' N X tt) ‚àß (‚àÄN X. P' N X ff) ‚àß
           (‚àÄN X Y. P' N X (propmm Y)) ‚àß
           (‚àÄN X P Q. P' N X P ‚àß P' N X Q ‚áí P' N X (P andmm Q)) ‚àß
           (‚àÄN X P Q. P' N X P ‚àß P' N X Q ‚áí P' N X (P ormm Q)) ‚àß
           (‚àÄN X Actions P. P' N X P ‚áí P' N X (Box Actions P)) ‚àß
           (‚àÄN X Actions P. P' N X P ‚áí P' N X (Dia Actions P)) ‚àß
           (‚àÄN X Z P.
              (‚àÄfs W.
                 (fs = frees P) ‚àß ¬¨(X ‚àâ fs ‚à® (X = Z)) ‚àß Z ‚àà frees N ‚àß
                 (W = variant (frees N ‚à™ fs) Z) ‚áí
                 P' N X (l_Sub [(Z,W)] P)) ‚àß
              (‚àÄfs.
                 (fs = frees P) ‚àß ¬¨(X ‚àâ fs ‚à® (X = Z)) ‚àß Z ‚àâ frees N ‚áí
                 P' N X P) ‚áí
              P' N X (nu Z P)) ‚àß
           (‚àÄN X Z P.
              (‚àÄfs W.
                 (fs = frees P) ‚àß ¬¨(X ‚àâ fs ‚à® (X = Z)) ‚àß Z ‚àà frees N ‚àß
                 (W = variant (frees N ‚à™ fs) Z) ‚áí
                 P' N X (l_Sub [(Z,W)] P)) ‚àß
              (‚àÄfs.
                 (fs = frees P) ‚àß ¬¨(X ‚àâ fs ‚à® (X = Z)) ‚àß Z ‚àâ frees N ‚áí
                 P' N X P) ‚áí
              P' N X (mu Z P)) ‚áí
           ‚àÄv v1 v2. P' v v1 v2

   [Subst_l_Sub]  Theorem

      |- ‚àÄf X Y. INFINITE ùïå(:Œ≤) ‚áí (Subst (propmm Y) X f = l_Sub [(X,Y)] f)

   [Subst_not_free]  Theorem

      |- ‚àÄN X Fm. INFINITE ùïå(:Œ≤) ‚áí X ‚àâ frees Fm ‚áí (Subst N X Fm = Fm)

   [Subst_same_size]  Theorem

      |- ‚àÄFm X Z.
           INFINITE ùïå(:Œ≤) ‚áí
           (fmla_size (Subst (propmm X) Z Fm) = fmla_size Fm)

   [UNION_SUBSET_MONOTONIC]  Theorem

      |- x1 ‚äÜ y1 ‚áí x2 ‚äÜ y2 ‚áí x1 ‚à™ x2 ‚äÜ y1 ‚à™ y2

   [alpha_LEM]  Theorem

      |- ‚àÄTrans Fm V Q X X'.
           INFINITE ùïå(:Œ≤) ‚áí
           X' ‚àâ frees Fm ‚áí
           (setsat Trans (Subst (propmm X') X Fm) (extend_env X' Q V) =
            setsat Trans Fm (extend_env X Q V))

   [alpha_frees]  Theorem

      |- ‚àÄY X Fm.
           INFINITE ùïå(:Œ≤) ‚áí
           Y ‚àâ frees Fm ‚áí
           (frees (Subst (propmm Y) X Fm) = rf Y X (frees Fm))

   [alpha_remove]  Theorem

      |- ‚àÄY X Fm.
           INFINITE ùïå(:Œ≤) ‚áí
           Y ‚àâ frees Fm ‚àß Y ‚â† X ‚áí
           X ‚àâ frees (Subst (propmm Y) X Fm)

   [extend_env_mmUpdate_EQ]  Theorem

      |- extend_env Z E V = mmUpdate Z V E

   [extend_env_mmUpdate_lemma]  Theorem

      |- extend_env Z E V Y = mmUpdate Z V E Y

   [fmla_size_ind]  Theorem

      |- ‚àÄP.
           (‚àÄf. (‚àÄg. fmla_size g < fmla_size f ‚áí P g) ‚áí P f) ‚áí
           ‚àÄn f. (fmla_size f = n) ‚áí P f

   [fmla_size_induction]  Theorem

      |- ‚àÄP.
           P tt ‚àß P ff ‚àß (‚àÄs. P (propmm s)) ‚àß
           (‚àÄf g. P f ‚àß P g ‚áí P (f andmm g)) ‚àß
           (‚àÄf g. P f ‚àß P g ‚áí P (f ormm g)) ‚àß
           (‚àÄActions f. P f ‚áí P (Box Actions f)) ‚àß
           (‚àÄActions f. P f ‚áí P (Dia Actions f)) ‚àß
           (‚àÄf. (‚àÄg. (fmla_size g = fmla_size f) ‚áí P g) ‚áí ‚àÄs. P (nu s f)) ‚àß
           (‚àÄf. (‚àÄg. (fmla_size g = fmla_size f) ‚áí P g) ‚áí ‚àÄs. P (mu s f)) ‚áí
           ‚àÄf. P f

   [frees_LEM]  Theorem

      |- ‚àÄFm l.
           INFINITE ùïå(:Œ≤) ‚áí
           ok_r l (frees Fm) ‚áí
           (frees (l_Sub l Fm) = gf l (frees Fm))

   [frees_SUBSET_vars]  Theorem

      |- ‚àÄf. frees f ‚äÜ vars f

   [frees_are_vars]  Theorem

      |- ‚àÄf x. x ‚àà frees f ‚áí x ‚àà vars f

   [frees_finite]  Theorem

      |- ‚àÄf. FINITE (frees f)

   [fv_1_1]  Theorem

      |- ‚àÄl fs.
           ok_r l fs ‚áí
           ‚àÄA B. A ‚àà fs ‚àß B ‚àà fs ‚áí ((fv l A = fv l B) ‚áî (A = B))

   [fv_BIJ]  Theorem

      |- ‚àÄl fs. ok_r l fs ‚áí BIJ (fv l) fs (gf l fs)

   [fv_IN_gf]  Theorem

      |- ‚àÄl fs (A::fs). fv l A ‚àà gf l fs

   [fv_LEM]  Theorem

      |- ‚àÄl s. gf l {s} = {fv l s}

   [fv_append]  Theorem

      |- ‚àÄl m. fv (l ++ m) = fv l ‚àò fv m

   [fv_def]  Theorem

      |- (‚àÄX. fv [] X = X) ‚àß
         ‚àÄl Z Y X.
           fv ((Y,Z)::l) X = (let X' = fv l X in if X' = Y then Z else X')

   [fv_ind]  Theorem

      |- ‚àÄP.
           (‚àÄX. P [] X) ‚àß (‚àÄY Z l X. P l X ‚áí P ((Y,Z)::l) X) ‚áí
           ‚àÄv v1. P v v1

   [fv_inj]  Theorem

      |- ‚àÄl fs.
           ok_r l fs ‚áí ‚àÄA B. A ‚àà fs ‚àß B ‚àà fs ‚áí (fv l A = fv l B) ‚áí (A = B)

   [fv_not_in]  Theorem

      |- ‚àÄfs gs Z l.
           ok_r l fs ‚àß gs ‚äÜ fs ‚àß Z ‚àà fs ‚àß Z ‚àâ gs ‚áí fv l Z ‚àâ gf l gs

   [gf_append]  Theorem

      |- ‚àÄl m fs. gf (l ++ m) fs = gf l (gf m fs)

   [gf_def]  Theorem

      |- (‚àÄfs. gf [] fs = fs) ‚àß
         ‚àÄl fs Y X. gf ((X,Y)::l) fs = rf Y X (gf l fs)

   [gf_delete]  Theorem

      |- ‚àÄl fs Z.
           ok_r l (Z INSERT fs) ‚áí
           (gf l (fs DELETE Z) = gf l fs DELETE fv l Z)

   [gf_empty]  Theorem

      |- ‚àÄl. gf l ‚àÖ = ‚àÖ

   [gf_finite]  Theorem

      |- ‚àÄfs. FINITE fs ‚áí ‚àÄl. FINITE (gf l fs)

   [gf_im]  Theorem

      |- ‚àÄl. gf l = IMAGE (fv l)

   [gf_ind]  Theorem

      |- ‚àÄP.
           (‚àÄfs. P [] fs) ‚àß (‚àÄX Y l fs. P l fs ‚áí P ((X,Y)::l) fs) ‚áí
           ‚àÄv v1. P v v1

   [gf_insert]  Theorem

      |- ‚àÄl fs Z. gf l (Z INSERT fs) = fv l Z INSERT gf l fs

   [gf_monotone]  Theorem

      |- ‚àÄl big sma. sma ‚äÜ big ‚áí gf l sma ‚äÜ gf l big

   [gf_union]  Theorem

      |- ‚àÄl fs fs'. gf l (fs ‚à™ fs') = gf l fs ‚à™ gf l fs'

   [gfp_monotone]  Theorem

      |- ‚àÄG H. (‚àÄs. G s ‚äÜ H s) ‚áí gfp G ‚äÜ gfp H

   [gl_append]  Theorem

      |- ‚àÄZ fs m l.
           gl (l ++ m) Z fs =
           gl l (fv (gl m Z fs) Z) (gf (gl m Z fs) fs) ++ gl m Z fs

   [gl_def]  Theorem

      |- (‚àÄfs Z. gl [] Z fs = []) ‚àß
         ‚àÄl fs Z Y X.
           gl ((X,Y)::l) Z fs =
           (let
              l' = gl l Z fs ;
              (fs',Z') = (gf l' fs,fv l' Z)
            in
              if X ‚àâ fs' ‚à® (X = Z') then l'
              else if Y = Z' then (X,Y)::(Z',variant (Y INSERT fs') Z')::l'
              else (X,Y)::l')

   [gl_ind]  Theorem

      |- ‚àÄP.
           (‚àÄZ fs. P [] Z fs) ‚àß
           (‚àÄX Y l Z fs. P l Z fs ‚áí P ((X,Y)::l) Z fs) ‚áí
           ‚àÄv v1 v2. P v v1 v2

   [half_gl_ok]  Theorem

      |- ‚àÄl Z fs.
           INFINITE ùïå(:Œ±) ‚àß FINITE fs ‚àß ok_r l (fs DELETE Z) ‚áí
           ok_r (gl l Z fs) (Z INSERT fs)

   [in_not_in_not_eq]  Theorem

      |- ‚àÄX Y s. X ‚àà s ‚àß Y ‚àâ s ‚áí X ‚â† Y

   [l_Sub_ID]  Theorem

      |- ‚àÄFm. l_Sub [(X,X)] Fm = Fm

   [l_Sub_ID_CONS]  Theorem

      |- ‚àÄf l. l_Sub ((X,X)::l) f = l_Sub l f

   [l_Sub_append]  Theorem

      |- ‚àÄP l m.
           INFINITE ùïå(:Œ≤) ‚áí
           ok_r m (frees P) ‚áí
           (l_Sub (l ++ m) P = l_Sub l (l_Sub m P))

   [l_Sub_nil]  Theorem

      |- ‚àÄFm. l_Sub [] Fm = Fm

   [l_Sub_same_size]  Theorem

      |- ‚àÄFm l. fmla_size (l_Sub l Fm) = fmla_size Fm

   [last_extension_counts]  Theorem

      |- ‚àÄx v v' f. extend_env x v (extend_env x v' f) = extend_env x v f

   [last_update_counts]  Theorem

      |- ‚àÄx v v' f. mmUpdate x (mmUpdate x f v') v = mmUpdate x f v

   [lfp_monotone]  Theorem

      |- ‚àÄG H. (‚àÄs. G s ‚äÜ H s) ‚áí lfp G ‚äÜ lfp H

   [mmsat_setsat]  Theorem

      |- (E,Trans,V) mmsat f ‚áî E ‚àà setsat Trans f V

   [muvar_not_free]  Theorem

      |- ‚àÄs Fm. s ‚àâ frees (mu s Fm)

   [not_in_gf]  Theorem

      |- ‚àÄA excl l fs Q.
           INFINITE ùïå(:Œ±) ‚áí
           FINITE excl ‚áí
           A ‚àâ gf ((A,variant (A INSERT excl) Q)::l) fs

   [nuvar_not_free]  Theorem

      |- ‚àÄs Fm. s ‚àâ frees (nu s Fm)

   [ok_r_def]  Theorem

      |- (‚àÄfs. ok_r [] fs ‚áî T) ‚àß
         ‚àÄl fs Y X.
           ok_r ((X,Y)::l) fs ‚áî ok_r l fs ‚àß (X ‚àà gf l fs ‚áí Y ‚àâ gf l fs)

   [ok_r_gl_insert]  Theorem

      |- ‚àÄl Z fs.
           INFINITE ùïå(:Œ±) ‚àß FINITE fs ‚àß ok_r l (fs DELETE Z) ‚áí
           ok_r (gl l Z fs) (Z INSERT fs) ‚àß
           ‚àÄX::fs DELETE Z. fv (gl l Z fs) X = fv l X

   [ok_r_ind]  Theorem

      |- ‚àÄP.
           (‚àÄfs. P [] fs) ‚àß (‚àÄX Y l fs. P l fs ‚áí P ((X,Y)::l) fs) ‚áí
           ‚àÄv v1. P v v1

   [ok_r_subset]  Theorem

      |- ‚àÄl big sma. sma ‚äÜ big ‚áí ok_r l big ‚áí ok_r l sma

   [ok_to_unroll_mu]  Theorem

      |- ‚àÄTrans Fm Z V.
           INFINITE ùïå(:Œ≤) ‚áí
           (setsat Trans (Subst (mu Z Fm) Z Fm) V =
            setsat Trans (mu Z Fm) V)

   [ok_to_unroll_nu]  Theorem

      |- ‚àÄTrans Fm Z V.
           INFINITE ùïå(:Œ≤) ‚áí
           (setsat Trans (Subst (nu Z Fm) Z Fm) V =
            setsat Trans (nu Z Fm) V)

   [pair_list_induction]  Theorem

      |- ‚àÄP. P [] ‚àß (‚àÄl. P l ‚áí ‚àÄX Y. P ((X,Y)::l)) ‚áí ‚àÄl. P l

   [setsat_EQ_satFun]  Theorem

      |- ‚àÄTrans Fm Z E V.
           setsat Trans Fm (extend_env Z E V) = satFun Trans Z V Fm E

   [setsat_is_mmfn_UNIV]  Theorem

      |- setsat Trans f V = mmfn Trans f ùïå(:Œ±) V

   [setsat_lemma]  Theorem

      |- (‚àÄV. setsat Trans tt V = ùïå(:'configuration)) ‚àß
         (‚àÄV. setsat Trans ff V = ‚àÖ) ‚àß
         (‚àÄZ V. setsat Trans (propmm Z) V = V Z) ‚àß
         (‚àÄFm1 Fm2 V.
            setsat Trans (Fm1 andmm Fm2) V =
            setsat Trans Fm1 V ‚à© setsat Trans Fm2 V) ‚àß
         (‚àÄFm1 Fm2 V.
            setsat Trans (Fm1 ormm Fm2) V =
            setsat Trans Fm1 V ‚à™ setsat Trans Fm2 V) ‚àß
         (‚àÄZ Fm V.
            setsat Trans (Box Actions Fm) V =
            {E |
             ‚àÄE' a. Trans a E E' ‚áí a ‚àà Actions ‚áí (E',Trans,V) mmsat Fm}) ‚àß
         (‚àÄZ Fm V.
            setsat Trans (Dia Actions Fm) V =
            {E |
             ‚àÉE' a. Trans a E E' ‚àß a ‚àà Actions ‚àß (E',Trans,V) mmsat Fm}) ‚àß
         (‚àÄZ Fm V.
            setsat Trans (nu Z Fm) V =
            gfp (ŒªQ. setsat Trans Fm (extend_env Z Q V))) ‚àß
         ‚àÄZ Fm V.
           setsat Trans (mu Z Fm) V =
           lfp (ŒªQ. setsat Trans Fm (extend_env Z Q V))

   [setsat_monotone]  Theorem

      |- ‚àÄTrans Fm Z V. monotone (ŒªQ. setsat Trans Fm (extend_env Z Q V))

   [silly_extend]  Theorem

      |- ‚àÄTrans Z Fm a V.
           Z ‚àâ frees Fm ‚áí
           (setsat Trans Fm (extend_env Z a V) = setsat Trans Fm V)

   [simple_ok_r_gl]  Theorem

      |- (‚àÄl s Fm.
            INFINITE ùïå(:Œ≤) ‚àß ok_r l (frees (nu s Fm)) ‚áí
            ok_r (gl l s (frees Fm)) (frees Fm)) ‚àß
         ‚àÄl s Fm.
           INFINITE ùïå(:Œ≤) ‚àß ok_r l (frees (mu s Fm)) ‚áí
           ok_r (gl l s (frees Fm)) (frees Fm)

   [simple_ok_r_gl_mu]  Theorem

      |- ‚àÄl s Fm.
           INFINITE ùïå(:Œ≤) ‚àß ok_r l (frees (mu s Fm)) ‚áí
           ok_r (gl l s (frees Fm)) (frees Fm)

   [simple_ok_r_gl_nu]  Theorem

      |- ‚àÄl s Fm.
           INFINITE ùïå(:Œ≤) ‚àß ok_r l (frees (nu s Fm)) ‚áí
           ok_r (gl l s (frees Fm)) (frees Fm)

   [uneq_extensions_commute]  Theorem

      |- ‚àÄv w x y f.
           y ‚â† x ‚áí
           (extend_env y w (extend_env x v f) =
            extend_env x v (extend_env y w f))

   [uneq_mmUpdates_commute]  Theorem

      |- ‚àÄv w x y f.
           y ‚â† x ‚áí
           (mmUpdate y (mmUpdate x f v) w = mmUpdate x (mmUpdate y f w) v)

   [unfold_mu_LEM]  Theorem

      |- ‚àÄTrans E V Z f.
           INFINITE ùïå(:Œ≤) ‚áí
           ((E,Trans,V) mmsat mu Z f ‚áî
            (E,Trans,V) mmsat Subst (mu Z f) Z f)

   [unfold_nu_LEM]  Theorem

      |- ‚àÄTrans E V Z f.
           INFINITE ùïå(:Œ≤) ‚áí
           ((E,Trans,V) mmsat nu Z f ‚áî
            (E,Trans,V) mmsat Subst (nu Z f) Z f)

   [variant_EXISTS]  Theorem

      |- ‚àÉvariant.
           ‚àÄexclvars.
             INFINITE ùïå(:'variable) ‚áí
             FINITE exclvars ‚áí
             ‚àÄv. variant exclvars v ‚àâ exclvars

   [variant_not_in]  Theorem

      |- ‚àÄs excl. INFINITE ùïå(:Œ±) ‚áí FINITE excl ‚áí variant excl s ‚àâ excl

   [vars_finite]  Theorem

      |- ‚àÄf. FINITE (vars f)


*)
end
